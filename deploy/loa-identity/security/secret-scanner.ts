/**
 * Secret Scanner - Pre-commit secret detection
 *
 * Scans staged grimoire files for secrets before git commits.
 * Blocks commits containing sensitive data.
 *
 * @module deploy/loa-identity/security/secret-scanner
 */

import { readFile } from 'fs/promises';
import { exec as execCb } from 'child_process';
import { promisify } from 'util';
import { PIIRedactor } from './pii-redactor.js';

const exec = promisify(execCb);

export interface ScanResult {
  clean: boolean;
  findings: SecretFinding[];
}

export interface SecretFinding {
  file: string;
  line: number;
  type: string;
  snippet: string;
  method: 'pattern' | 'entropy';
}

/**
 * SecretScanner detects secrets in files before they can be committed.
 */
export class SecretScanner {
  private redactor: PIIRedactor;

  constructor() {
    this.redactor = new PIIRedactor();
  }

  /**
   * Scan files for secrets
   */
  async scanFiles(files: string[]): Promise<ScanResult> {
    const findings: SecretFinding[] = [];

    for (const file of files) {
      try {
        const content = await readFile(file, 'utf-8');
        const lines = content.split('\n');

        for (let i = 0; i < lines.length; i++) {
          const result = this.redactor.process(lines[i]);

          if (result.blocked || result.redactions.length > 0) {
            for (const redaction of result.redactions) {
              findings.push({
                file,
                line: i + 1,
                type: redaction.type,
                snippet: this.truncateSnippet(lines[i], 50),
                method: redaction.method,
              });
            }

            if (result.blocked) {
              findings.push({
                file,
                line: i + 1,
                type: result.reason || 'blocked_content',
                snippet: '[BLOCKED - Content hidden]',
                method: 'pattern',
              });
            }
          }
        }
      } catch (e) {
        console.warn(`[secret-scanner] Error scanning ${file}:`, e);
      }
    }

    return {
      clean: findings.length === 0,
      findings,
    };
  }

  /**
   * Scan files staged for git commit
   */
  async scanStagedFiles(pathPattern = 'grimoires/'): Promise<ScanResult> {
    try {
      const { stdout } = await exec(
        `git diff --cached --name-only -- "${pathPattern}"`
      );
      const files = stdout
        .trim()
        .split('\n')
        .filter(Boolean)
        .map((f) => f.trim());

      if (files.length === 0) {
        return { clean: true, findings: [] };
      }

      // Resolve to absolute paths
      const cwd = process.cwd();
      const absolutePaths = files.map((f) => `${cwd}/${f}`);

      return this.scanFiles(absolutePaths);
    } catch (e) {
      console.warn('[secret-scanner] Error getting staged files:', e);
      return { clean: true, findings: [] };
    }
  }

  /**
   * Pre-commit hook implementation
   */
  async preCommitHook(): Promise<boolean> {
    console.log('[secret-scanner] Scanning staged grimoire files...');

    const result = await this.scanStagedFiles('grimoires/');

    if (!result.clean) {
      console.error('\n[security] Secrets detected in staged files:');
      console.error('─'.repeat(60));

      for (const finding of result.findings) {
        console.error(`  ${finding.file}:${finding.line}`);
        console.error(`    Type: ${finding.type} (${finding.method})`);
        console.error(`    Snippet: ${finding.snippet}`);
        console.error('');
      }

      console.error('─'.repeat(60));
      console.error('[security] Commit blocked. Remove secrets and try again.');
      console.error(
        '[security] Use `git diff --cached` to see staged changes.\n'
      );

      return false;
    }

    console.log('[secret-scanner] No secrets found. Commit allowed.');
    return true;
  }

  /**
   * Truncate snippet for display
   */
  private truncateSnippet(line: string, maxLen: number): string {
    const trimmed = line.trim();
    if (trimmed.length <= maxLen) return trimmed;
    return trimmed.substring(0, maxLen - 3) + '...';
  }

  /**
   * Generate git hook script
   */
  generateHookScript(): string {
    return `#!/bin/bash
# Beauvoir Pre-commit Secret Scanner Hook
# Generated by deploy/loa-identity/security/secret-scanner.ts

# Run the scanner
node --experimental-specifier-resolution=node \\
  -e "import('./deploy/loa-identity/security/secret-scanner.js').then(m => m.runPreCommitHook())"

exit_code=$?

if [ $exit_code -ne 0 ]; then
  echo ""
  echo "Commit aborted due to detected secrets."
  echo "Review findings above and remove sensitive data."
  exit 1
fi

exit 0
`;
  }
}

/**
 * Entry point for pre-commit hook
 */
export async function runPreCommitHook(): Promise<void> {
  const scanner = new SecretScanner();
  const success = await scanner.preCommitHook();
  process.exit(success ? 0 : 1);
}
